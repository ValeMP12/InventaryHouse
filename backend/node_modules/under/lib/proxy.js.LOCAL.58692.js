/*
  most of the send_request code is based on http-proxy
  there's a few optimizations around error handling
  and support for callbacks as well.
*/

var http  = require('http'),
    agent = new http.Agent();

agent.maxSockets = 100;

var debug = false;
var defaults = {};

var messages = {
  499: 'Client request closed.',
  500: 'Server error.',
  502: 'Timed out when waiting for backend.',
  503: 'Backend seems to be down.',
  599: 'Server overload.'
}

var errors = {
  'ECONNRESET':    502, // when aborted (timeout)
  'ECONNREFUSED':  503,
  'EAGAIN':        503, // syscall: 'connect'
  'ENOTFOUND':     503,
  'ENOENT':        503,
  'EMFILE':        599,
  'EADDRNOTAVAIL': 599  // no available sockets/ports
}

var log = function(msg, err) {
  if (!debug) return;
  return err ? console.log(msg, err) : console.log(msg);
}

var upperize = function(str) {
  return str.replace(/(?:^|\s|\-)\S/g, function(a) { return a.toUpperCase(); });
}

var remove_matching = function(arr, obj) {
  return arr.filter(function(el) {
    return !Object.keys(el).every(function(key) {
      return el[key] === obj[key];
    });
  })
}

////////////////////////////////////////////////////////////
// helpers
////////////////////////////////////////////////////////////

var get_target = function(backends) {
  var list = backends || defaults.backends;
  if (!list || list.length == 0)
    throw('No backends set!');

  if (list.length == 1)
    return list[0];

  var target = list.shift();
  list.push(target);
  return target;
}

var get_backend_name = function(target) {
  if (target.socketPath)
    return target.socketPath.split('/').pop()
  else
    return target.host + ':' + target.port;
}

var flag_backend = function(target) {
  // no point in flagging backend if empty or just one
  if (!defaults.backends || defaults.backends.length <= 1)
    return;

  var removed = remove_matching(defaults.backends, target);
  if (removed.length == defaults.backends.length)
    return log('Unable to find matching backend.');

  log('Flagging server in backend list!');
  defaults.backends = removed;

  setTimeout(function() {
    log('Unflagging server in backend list!');
    defaults.backends.push(target);
  }, defaults.flag_timeout || 10 * 1000) // 10 seconds by default
}

var is_socket_request = function(req) {
  return (req.headers.accept && req.headers.accept == 'text/event-stream');
}

////////////////////////////////////////////////////////////
// the main act
////////////////////////////////////////////////////////////

exports.setup = function(options) {
  defaults = options;

  if (options.max_active || options.max_sockets)
    agent.maxSockets = (options.max_active || options.max_sockets);

  if (options.debug)
    debug = options.debug;

  return function(req, res) {
    var opts = arguments[2] || {};
    var cb   = arguments[3];

    opts.retry_failed = options.retry_failed;
    exports.send(req, res, opts, cb);
  };
}

exports.send = function(req, res) {

  log('Proxying request to ' + req.url);

  var timer,
      returned = false,
      error = false,
      opts  = arguments[2] || {},
      cb    = arguments[3];

  var target           = opts.backend || defaults.backend || get_target(opts.backends),
      backend_name     = (defaults.sign || opts.sign) === true ? get_backend_name(target) : null;

  var should_timeout   = !is_socket_request(req),
      timeout          = should_timeout ? (opts.timeout || defaults.timeout || 60000) : 0;

  var header_func      = opts.lowercase ? function(h) { return h } : upperize;
  // req.connection.setTimeout(timeout); // we'll set or own timer

  var request_opts     = target;
  request_opts.agent   = agent;
  request_opts.method  = req.method;
  request_opts.path    = req.url;
  request_opts.headers = req.headers;

  // include X-Forwarded-(For|Port|Proto) headers
  if (req.connection && req.socket) {
    var connection_data = {
      'for'   : req.connection.remoteAddress || req.socket.remoteAddress,
      'port'  : req.connection.remotePort || req.socket.remotePort,
      'proto' : req.secure ? 'https' : 'http'
    }

    for (var key in connection_data) {
      var name = 'x-forwarded-' + key;
      if (request_opts.headers[name])
        request_opts.headers[name] += ', ' + connection_data[key];
      else
        request_opts.headers[name] = connection_data[key];
    }
  }

  var done = function(err) {
    if (returned) return;
    cb && cb(err, res);
    returned = true;
  }

  var proxyError = function(err) {
    error = true;
    if (timer) clearTimeout(timer);
    log('Proxy request error:', err.message);

    if (!res.headersSent) {
      if (opts.retry_failed === true) {
        // retry is enabled, so wait one second and resend the request
        return setTimeout(function() {
          opts.retry_failed = false;
          exports.send(req, res, opts, cb);
        }, 1000);
      } else {
        var code = req.aborted ? 499 : (errors[err.code] || 500);
        res.writeHead(code, {'Content-Type': 'text/plain', 'Connection': 'close'});
      }
    }

    if (req.method !== 'HEAD')
      res.write(messages[res.statusCode] + "\n");

    try { res.end() }
    catch (ex) { log('res.end on error failed', ex) }

    // if error code is known (502, 503, etc), mark backend as unavailable
    if (errors[err.code])
      flag_backend(target);

    done(err);
  };

  var proxyRequest = http.request(request_opts, function(response) {

    if (timer) clearTimeout(timer);
    if (res.finished) {
      log('Response already finished!');
      return done();
    }

    /*

    if (response.headers.connection) {
      if (req.headers.connection) {
        response.headers.connection = req.headers.connection
      } else {
        response.headers.connection = 'close'
      }
    }

    this throws an error if running on node 0.10 or later:
    Error: Cannot switch to old mode now.

    response.connection.on('end', function() {
      if (response.readable && response.resume)
        response.resume();
    });
    */

    // handle response headers
    var headers = response.headers; // node returns them in lowercase form
    if (backend_name)
      headers['X-Backend'] = backend_name;
    if (req.method == 'HEAD')
      delete(headers['content-length']);

    // instead of calling writeHead, we use setHeader to allow modifying them later
    res.statusCode = response.statusCode;
    for (var h in headers) {
      res.setHeader(header_func(h), headers[h]);
    }

    response.once('end', function() {
      // log('Proxy response ended.')
      if (error) return;

      done();
      proxyRequest.removeListener('error', proxyError);
      try { res.end() }
      catch (ex) { log("res.end failed: %s", ex.message) }
    });

    // pipe data
    response.pipe(res);
  });

  req.once('aborted', function() {
    log('Request aborted!')
    req.aborted = true;
    proxyRequest.abort();
  });

  req.once('close', function() {
    log('Request closed.')
    if (!error) proxyRequest.abort();
  });

  req.on('data', function(chunk) {

    if (!error) {
      var flushed = proxyRequest.write(chunk);
      if (!flushed) {
        req.pause();
        proxyRequest.once('drain', function() {
          try { req.resume() }
          catch (ex) { log('req.resume failed', ex) }
        });

        setTimeout(function() {
          proxyRequest.emit('drain');
        }, 100);
      }
    }

  });

  proxyRequest.once('error', function(err) {
    // if we proxied a HEAD request and we received a body, we would get this error
    if (err.code == 'HPE_INVALID_CONSTANT') {
      if (req.method == 'HEAD') {
        log('HEAD response contained a body!')
      } else {
        log('Invalid Content-Length!');
      }
      return res.end();
    }

    proxyError(err);
  });

  if (req.complete) {
    if (!error) proxyRequest.end();
  } else {
    req.once('end', function() {
      if (!error) proxyRequest.end();
    });
  }

  if (timeout <= 0)
    return log('Not timing out this request: ' + req.url);

  timer = setTimeout(function() {
    log('Timed out after ' + timeout/1000 + ' seconds! Aborting request.')
    if (!res.writable)
      return done(new Error('Proxy request timeout!'));

    proxyRequest.abort();
  }, timeout);

}
